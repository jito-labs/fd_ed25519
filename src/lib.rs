use std::ffi::CStr;

// This includes the bindings.rs file generated by build.rs
// and places its content into a module named raw_bindings (or any name you choose)
#[allow(non_upper_case_globals)]
#[allow(non_camel_case_types)]
#[allow(non_snake_case)]
#[allow(dead_code)]
mod raw_bindings {
    include!(concat!(env!("OUT_DIR"), "/bindings.rs"));
}

// Re-export the opaque fd_sha512_t type and any relevant constants.
// The exact type of fd_sha512_t (e.g., struct, void pointer) depends on bindgen's output.
// If it's a struct, you might need to ensure it's properly aligned and sized if you manipulate it directly.
// Typically, it's treated as an opaque pointer or an opaque struct by bindgen.
pub use raw_bindings::fd_sha512_t;
use raw_bindings::{uchar, ulong}; // uchar and ulong are expected to be defined by bindgen

pub const FD_ED25519_PUBLIC_KEY_LEN: usize = 32;
pub const FD_ED25519_PRIVATE_KEY_LEN: usize = 32;
pub const FD_ED25519_SIGNATURE_LEN: usize = 64;

// Error codes from fd_ed25519.h (already allowlisted in build.rs, re-export for convenience)
pub const FD_ED25519_SUCCESS: i32 = raw_bindings::FD_ED25519_SUCCESS as i32;
pub const FD_ED25519_ERR_SIG: i32 = raw_bindings::FD_ED25519_ERR_SIG;
pub const FD_ED25519_ERR_PUBKEY: i32 = raw_bindings::FD_ED25519_ERR_PUBKEY;
pub const FD_ED25519_ERR_MSG: i32 = raw_bindings::FD_ED25519_ERR_MSG;

/// Initializes a SHA-512 context.
///
/// Wraps the `fd_sha512_init` C function. This function prepares the SHA-512
/// context for a new hashing session, discarding any previous state.
///
/// # Arguments
/// * `sha`: A mutable reference to an `fd_sha512_t` context to be initialized.
///
/// # Returns
/// A mutable reference to the initialized `fd_sha512_t` context.
///
/// # Safety
/// The underlying C function `fd_sha512_init` is called. The caller must ensure
/// `sha` is a valid pointer to an `fd_sha512_t` structure. The C function
/// modifies the state pointed to by `sha`.
pub fn fd_sha512_init(sha: &mut fd_sha512_t) -> &mut fd_sha512_t {
    unsafe {
        // The C function returns the same pointer, so we can directly use `sha`
        // after the call, effectively returning the mutable reference passed in.
        raw_bindings::fd_sha512_init(sha as *mut fd_sha512_t);
    }
    sha
}

/// Generates an Ed25519 public key from a private key.
///
/// # Arguments
/// * `private_key`: A 32-byte Ed25519 private key.
/// * `sha`: A mutable reference to an `fd_sha512_t` context.
///
/// # Returns
/// A 32-byte Ed25519 public key.
///
/// # Safety
/// The underlying C function `fd_ed25519_public_from_private` is called.
/// The caller must ensure `sha` is a valid pointer to an initialized SHA512 context.
pub fn fd_ed25519_public_from_private(
    private_key: &[u8; FD_ED25519_PRIVATE_KEY_LEN],
    sha: &mut fd_sha512_t,
) -> [u8; FD_ED25519_PUBLIC_KEY_LEN] {
    let mut public_key_out = [0u8; FD_ED25519_PUBLIC_KEY_LEN];
    unsafe {
        raw_bindings::fd_ed25519_public_from_private(
            public_key_out.as_mut_ptr() as *mut uchar,
            private_key.as_ptr() as *const uchar,
            sha as *mut fd_sha512_t,
        );
    }
    public_key_out
}

/// Signs a message using an Ed25519 key pair.
///
/// # Arguments
/// * `msg`: The message to sign.
/// * `public_key`: The 32-byte Ed25519 public key.
/// * `private_key`: The 32-byte Ed25519 private key.
/// * `sha`: A mutable reference to an `fd_sha512_t` context.
///
/// # Returns
/// A 64-byte Ed25519 signature.
///
/// # Safety
/// The underlying C function `fd_ed25519_sign` is called.
/// The caller must ensure `sha` is a valid pointer to an initialized SHA512 context
/// and that `public_key` corresponds to `private_key`.
pub fn fd_ed25519_sign(
    msg: &[u8],
    public_key: &[u8; FD_ED25519_PUBLIC_KEY_LEN],
    private_key: &[u8; FD_ED25519_PRIVATE_KEY_LEN],
    sha: &mut fd_sha512_t,
) -> [u8; FD_ED25519_SIGNATURE_LEN] {
    let mut sig_out = [0u8; FD_ED25519_SIGNATURE_LEN];
    unsafe {
        raw_bindings::fd_ed25519_sign(
            sig_out.as_mut_ptr() as *mut uchar,
            msg.as_ptr() as *const uchar,
            msg.len() as ulong,
            public_key.as_ptr() as *const uchar,
            private_key.as_ptr() as *const uchar,
            sha as *mut fd_sha512_t,
        );
    }
    sig_out
}

/// Verifies an Ed25519 signature against a message and public key.
///
/// # Arguments
/// * `msg`: The message that was signed.
/// * `sig`: The 64-byte signature to verify.
/// * `public_key`: The 32-byte public key to use for verification.
/// * `sha`: A mutable reference to an `fd_sha512_t` context.
///
/// # Returns
/// `Ok(())` if the signature is valid.
/// `Err(error_code)` if verification fails, where `error_code` is one of
/// `FD_ED25519_ERR_SIG`, `FD_ED25519_ERR_PUBKEY`, or `FD_ED25519_ERR_MSG`.
///
/// # Safety
/// The underlying C function `fd_ed25519_verify` is called.
/// The caller must ensure `sha` is a valid pointer to an initialized SHA512 context.
pub fn fd_ed25519_verify(
    msg: &[u8],
    sig: &[u8; FD_ED25519_SIGNATURE_LEN],
    public_key: &[u8; FD_ED25519_PUBLIC_KEY_LEN],
    sha: &mut fd_sha512_t,
) -> Result<(), i32> {
    let result = unsafe {
        raw_bindings::fd_ed25519_verify(
            msg.as_ptr() as *const uchar,
            msg.len() as ulong,
            sig.as_ptr() as *const uchar,
            public_key.as_ptr() as *const uchar,
            sha as *mut fd_sha512_t,
        )
    };

    if result == FD_ED25519_SUCCESS {
        Ok(())
    } else {
        Err(result)
    }
}

/// Represents an item for batch Ed25519 signature verification.
pub struct Ed25519BatchVerificationItem<'a> {
    pub signature: &'a [u8; FD_ED25519_SIGNATURE_LEN],
    pub public_key: &'a [u8; FD_ED25519_PUBLIC_KEY_LEN],
    pub sha_context: &'a mut fd_sha512_t,
}

/// Maximum batch size supported by `fd_ed25519_verify_batch_single_msg`.
pub const FD_ED25519_BATCH_MAX_SIZE: usize = 16;

/// Verifies a batch of Ed25519 signatures for a single message.
///
/// All signatures in the batch are verified against the same message `msg`.
/// Each item in the `items` slice provides a signature, a public key,
/// and a dedicated SHA-512 context.
///
/// # Arguments
/// * `msg`: The single message that was signed for all items in the batch.
/// * `items`: A slice of `Ed25519BatchVerificationItem` structs. The length of this
///   slice must be between 1 and `FD_ED25519_BATCH_MAX_SIZE` (inclusive).
///
/// # Returns
/// `Ok(())` if all signatures in the batch are valid.
/// `Err(error_code)` if any verification fails or if `items` is empty or too large.
/// The `error_code` corresponds to `FD_ED25519_ERR_*` constants.
///
/// # Safety
/// The underlying C function `fd_ed25519_verify_batch_single_msg` is called.
/// The caller must ensure all `sha_context` fields in `items` point to valid,
/// initialized SHA512 contexts. The C function expects contiguous arrays for
/// signatures and public keys, which this wrapper constructs.
pub fn fd_ed25519_verify_batch_single_msg(
    msg: &[u8],
    items: &mut [Ed25519BatchVerificationItem],
) -> Result<(), i32> {
    let batch_sz = items.len();
    if batch_sz == 0 || batch_sz > FD_ED25519_BATCH_MAX_SIZE {
        // The C code returns FD_ED25519_ERR_SIG for batch_sz == 0 or > MAX (16)
        return Err(FD_ED25519_ERR_SIG);
    }

    // Pre-allocate with exact capacity to avoid reallocations
    let mut signatures_flat: Vec<uchar> = Vec::with_capacity(batch_sz * FD_ED25519_SIGNATURE_LEN);
    let mut public_keys_flat: Vec<uchar> = Vec::with_capacity(batch_sz * FD_ED25519_PUBLIC_KEY_LEN);
    let mut sha_contexts_ptrs: Vec<*mut fd_sha512_t> = Vec::with_capacity(batch_sz);

    for item in items.iter_mut() {
        signatures_flat.extend_from_slice(item.signature);
        public_keys_flat.extend_from_slice(item.public_key);
        sha_contexts_ptrs.push(item.sha_context as *mut _); // Convert &mut to *mut
    }

    let result = unsafe {
        raw_bindings::fd_ed25519_verify_batch_single_msg(
            msg.as_ptr() as *const uchar,
            msg.len() as ulong,
            signatures_flat.as_ptr() as *const uchar, // Pointer to the flat array of signatures
            public_keys_flat.as_ptr() as *const uchar, // Pointer to the flat array of public keys
            sha_contexts_ptrs.as_mut_ptr(),           // Pointer to the array of *mut fd_sha512_t
            batch_sz as uchar,
        )
    };

    if result == FD_ED25519_SUCCESS {
        Ok(())
    } else {
        Err(result)
    }
}

/// Validates an Ed25519 public key encoded in bytes.
///
/// # Arguments
/// * `public_key_bytes`: A 32-byte slice representing the public key.
///
/// # Returns
/// `true` if the public key is valid according to Ed25519 rules (canonical, on curve, not small order).
/// `false` otherwise.
///
/// # Safety
/// This function calls the C function `fd_ed25519_point_validate`.
/// The caller must ensure `public_key_bytes` points to a valid 32-byte region of memory.
pub fn fd_ed25519_point_validate(public_key_bytes: &[u8; FD_ED25519_PUBLIC_KEY_LEN]) -> bool {
    let mut t: raw_bindings::fd_ed25519_point_t = unsafe { std::mem::zeroed() };

    /* fd_ed25519_point_frombytes deserializes a 32-byte buffer buf into a
    point r, and returns r (on success, NULL on error).
    buf is in little endian form, according to RFC 8032.
    Cost: 1sqrt ~= 1inv ~= 250mul */
    unsafe {
        !raw_bindings::fd_ed25519_point_frombytes(&mut t, public_key_bytes.as_ptr() as *const uchar)
            .is_null()
    }
}

/// Converts an Ed25519 error code into a human-readable string.
///
/// # Arguments
/// * `err`: The error code (e.g., `FD_ED25519_ERR_SIG`).
///
/// # Returns
/// A static string slice describing the error. Returns "unknown" for unrecognized codes.
///
/// # Safety
/// The underlying C function `fd_ed25519_strerror` is called. Assumes `err` is a valid
/// error code known to the C library, or it will return the "unknown" string.
pub fn fd_ed25519_strerror(err: std::os::raw::c_int) -> &'static str {
    unsafe {
        let c_str_ptr = raw_bindings::fd_ed25519_strerror(err);
        if c_str_ptr.is_null() {
            // Should not happen with the C function's current implementation, but good practice.
            return "unknown (null pointer from strerror)";
        }
        // The C function returns pointers to static string literals.
        CStr::from_ptr(c_str_ptr)
            .to_str()
            .unwrap_or("unknown (UTF-8 conversion error)")
    }
}

#[cfg(test)]
mod tests {
    use base64::{prelude::BASE64_STANDARD, Engine};
    use hex_literal::hex;
    use solana_sdk::{pubkey::Pubkey, transaction::VersionedTransaction};

    // If this test module is inside src/lib.rs, use super::*
    // If your crate is named something else, adjust accordingly.
    // Assuming the functions from your fd_ed25519_bindings/src/lib.rs are accessible
    // via `crate::` or `super::` depending on where this test module is placed.
    // For this example, let's assume they are in the root of the crate `fd_ed25519_bindings`.
    use super::*;

    #[test]
    fn verify_specific_solana_transaction_with_fd_ed25519() {
        let txn_b64 = "AVXo5X7UNzpuOmYzkZ+fqHDGiRLTSMlWlUCcZKzEV5CIKlrdvZa3/2GrJJfPrXgZqJbYDaGiOnP99tI/sRJfiwwBAAEDRQ/n5E5CLbMbHanUG3+iVvBAWZu0WFM6NoB5xfybQ7kNwwgfIhv6odn2qTUu/gOisDtaeCW1qlwW/gx3ccr/4wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAvsInicc+E3IZzLqeA+iM5cn9kSaeFzOuClz1Z2kZQy0BAgIAAQwCAAAAAPIFKgEAAAA=";
        let txn_bytes = BASE64_STANDARD.decode(txn_b64).unwrap();
        let txn: VersionedTransaction = bincode::deserialize(&txn_bytes).unwrap();
        let message_bytes = txn.message.serialize();
        assert!(!txn.signatures.is_empty(), "Transaction has no signatures.");
        let signature_slice = txn.signatures[0].as_ref();
        assert_eq!(
            signature_slice.len(),
            FD_ED25519_SIGNATURE_LEN,
            "Signature length mismatch."
        );
        let mut signature_array = [0u8; FD_ED25519_SIGNATURE_LEN];
        signature_array.copy_from_slice(signature_slice);

        // The public key of the signer.
        // For simple transactions, the first signature corresponds to the first account key marked as a signer.
        // The `static_account_keys` are the accounts loaded by the transaction.
        // The first key in `static_account_keys` is typically the fee payer and primary signer.
        assert!(
            !txn.message.static_account_keys().is_empty(),
            "Transaction message has no static account keys."
        );
        let public_key_solana: &Pubkey = &txn.message.static_account_keys()[0];
        let public_key_slice = public_key_solana.as_ref();
        assert_eq!(
            public_key_slice.len(),
            FD_ED25519_PUBLIC_KEY_LEN,
            "Public key length mismatch."
        );
        let mut public_key_array = [0u8; FD_ED25519_PUBLIC_KEY_LEN];
        public_key_array.copy_from_slice(public_key_slice);

        let sha_ctx = std::mem::MaybeUninit::<fd_sha512_t>::uninit();
        // no need to init, already done here:
        // https://github.com/firedancer-io/firedancer/blob/91c4a47971fc26c3e01025a1a9972d6320a2961a/src/ballet/ed25519/fd_ed25519_user.c#L205
        let mut initialized_sha_ctx = unsafe { sha_ctx.assume_init() };

        let verification_result = fd_ed25519_verify(
            &message_bytes,
            &signature_array,
            &public_key_array,
            &mut initialized_sha_ctx,
        );

        assert!(
            verification_result.is_ok(),
            "Signature verification failed. Error: {:?}",
            verification_result
                .err()
                .map(|code| fd_ed25519_strerror(code))
        );
    }

    // Helper to create and initialize sha context
    fn new_sha_context() -> fd_sha512_t {
        let mut sha_ctx = std::mem::MaybeUninit::<fd_sha512_t>::uninit();
        unsafe {
            raw_bindings::fd_sha512_init(sha_ctx.as_mut_ptr());
            sha_ctx.assume_init()
        }
    }

    #[test]
    fn test_sign_and_verify_rfc8032_tc1() {
        let mut sha_ctx = new_sha_context();
        let private_key_seed =
            hex!("9d61b19deffd5a60ba844af492ec2cc44449c5697b326919703bac031cae7f60");
        let public_key = hex!("d75a980182b10ab7d54bfed3c964073a0ee172f3daa62325af021a68f707511a");
        let msg = b"";
        let expected_sig = hex!("e5564300c360ac729086e2cc806e828a84877f1eb8e5d974d873e065224901555fb8821590a33bacc61e39701cf9b46bd25bf5f0595bbe24655141438e7a100b");

        // The C fd_ed25519_sign function expects the *actual* 32-byte private key, not the seed.
        // The ballet library's fd_ed25519_public_from_private derives the public key AND effectively
        // processes the seed into the private key form (first 32 bytes of SHA512(seed)).
        // However, fd_ed25519_sign takes this *seed* as `private_key` argument.
        // This seems to be a convention in some Ed25519 libraries where "private key" might refer to the seed.
        let sig = fd_ed25519_sign(msg, &public_key, &private_key_seed, &mut sha_ctx);
        assert_eq!(sig, expected_sig, "Signature mismatch for RFC8032 TC1");

        let verify_result = fd_ed25519_verify(msg, &sig, &public_key, &mut new_sha_context());
        assert_eq!(verify_result, Ok(()), "Verification failed for RFC8032 TC1");
    }

    #[test]
    fn test_sign_and_verify_empty_message() {
        let mut sha_ctx = new_sha_context();
        let private_key_seed =
            hex!("57835dc6a20e4efd70e90882dbd832b577dbc469960284e0ee718fb526d2ec84");
        let public_key = fd_ed25519_public_from_private(&private_key_seed, &mut new_sha_context());

        let msg = b"";
        // Expected signature from test_ed25519.c for this key and empty message
        let expected_sig = hex!("d65759870ce42b34fd955871f0371ce1c9a976edbe98417b84541bb4c68b65a0673799895c61d530624ffbf92c047d47d4eb4cd1bac2ecee1365faebb53a6303");

        let sig = fd_ed25519_sign(msg, &public_key, &private_key_seed, &mut sha_ctx);
        assert_eq!(sig, expected_sig, "Signature mismatch for empty message");

        let verify_result = fd_ed25519_verify(msg, &sig, &public_key, &mut new_sha_context());
        assert_eq!(
            verify_result,
            Ok(()),
            "Verification failed for empty message"
        );
    }

    #[test]
    fn test_sign_and_verify_random_message() {
        let mut sha_ctx = new_sha_context();
        let mut private_key_seed = [0u8; FD_ED25519_PRIVATE_KEY_LEN];
        rand::fill(&mut private_key_seed);

        let public_key = fd_ed25519_public_from_private(&private_key_seed, &mut new_sha_context());

        let mut msg = [0u8; 128];
        rand::fill(&mut msg);

        let sig = fd_ed25519_sign(&msg, &public_key, &private_key_seed, &mut sha_ctx);

        let verify_result = fd_ed25519_verify(&msg, &sig, &public_key, &mut new_sha_context());
        assert_eq!(
            verify_result,
            Ok(()),
            "Verification failed for random message"
        );

        // Test with corrupted signature
        let mut corrupted_sig = sig;
        corrupted_sig[0] ^= 0x01; // Flip one bit
        let verify_result_corrupted_sig =
            fd_ed25519_verify(&msg, &corrupted_sig, &public_key, &mut new_sha_context());
        assert!(
            verify_result_corrupted_sig == Err(FD_ED25519_ERR_SIG)
                || verify_result_corrupted_sig == Err(FD_ED25519_ERR_PUBKEY)
                || verify_result_corrupted_sig == Err(FD_ED25519_ERR_MSG)
        );

        // Test with corrupted message
        let mut corrupted_msg = msg;
        corrupted_msg[0] ^= 0x01;
        let verify_result_corrupted_msg =
            fd_ed25519_verify(&corrupted_msg, &sig, &public_key, &mut new_sha_context());
        assert!(
            verify_result_corrupted_msg == Err(FD_ED25519_ERR_SIG)
                || verify_result_corrupted_msg == Err(FD_ED25519_ERR_PUBKEY)
                || verify_result_corrupted_msg == Err(FD_ED25519_ERR_MSG)
        );

        // Test with corrupted public key
        let mut corrupted_public_key = public_key;
        corrupted_public_key[0] ^= 0x01;
        let verify_result_corrupted_pk =
            fd_ed25519_verify(&msg, &sig, &corrupted_public_key, &mut new_sha_context());
        assert!(
            verify_result_corrupted_pk == Err(FD_ED25519_ERR_SIG)
                || verify_result_corrupted_pk == Err(FD_ED25519_ERR_PUBKEY)
                || verify_result_corrupted_pk == Err(FD_ED25519_ERR_MSG)
        );
    }

    // Wycheproof test vectors
    // (Test vectors are taken from fd_ed25519_bindings/vendor/ballet/ed25519/test_ed25519_wycheproof.c)
    #[derive(Debug)]
    struct WycheproofEd25519VerifyTest {
        tc_id: u32,
        comment: &'static str,
        msg: &'static [u8],
        public_key: [u8; FD_ED25519_PUBLIC_KEY_LEN],
        sig: [u8; FD_ED25519_SIGNATURE_LEN],
        expected_ok: bool,
    }

    // Only a subset for brevity in this sigverify. Real implementation would include all.
    const WYCHEPROOF_TEST_VECTORS: &[WycheproofEd25519VerifyTest] = &[
        WycheproofEd25519VerifyTest {
            tc_id: 1,
            comment: "",
            msg: b"",
            sig: hex!("d4fbdb52bfa726b44d1786a8c0d171c3e62ca83c9e5bbe63de0bb2483f8fd6cc1429ab72cafc41ab56af02ff8fcc43b99bfe4c7ae940f60f38ebaa9d311c4007"),
            public_key: hex!("7d4d0e7f6153a69b6242b522abbee685fda4420f8834b108c3bdae369ef549fa"),
            expected_ok: true,
        },
        WycheproofEd25519VerifyTest {
            tc_id: 2,
            comment: "",
            msg: b"\x78",
            sig: hex!("d80737358ede548acb173ef7e0399f83392fe8125b2ce877de7975d8b726ef5b1e76632280ee38afad12125ea44b961bf92f1178c9fa819d020869975bcbe109"),
            public_key: hex!("7d4d0e7f6153a69b6242b522abbee685fda4420f8834b108c3bdae369ef549fa"),
            expected_ok: true,
        },
        // ... (More test cases would go here) ...
        WycheproofEd25519VerifyTest {
            tc_id: 10,
            comment: "special values for r and s",
            msg: b"\x3f",
            sig: hex!("00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"),
            public_key: hex!("7d4d0e7f6153a69b6242b522abbee685fda4420f8834b108c3bdae369ef549fa"),
            expected_ok: false,
        },
        WycheproofEd25519VerifyTest {
            tc_id: 63,
            comment: "checking malleability ",
            msg: b"Test",
            sig: hex!("7c38e026f29e14aabd059a0f2db8b0cd783040609a8be684db12f82a27774ab067654bce3832c2d76f8f6f5dafc08d9339d4eef676573336a5c51eb6f946b31d"),
            public_key: hex!("7d4d0e7f6153a69b6242b522abbee685fda4420f8834b108c3bdae369ef549fa"),
            expected_ok: false,
        },
    ];

    #[test]
    fn test_ed25519_verify_wycheproof() {
        for test_case in WYCHEPROOF_TEST_VECTORS {
            let mut sha_ctx = new_sha_context();
            let result = fd_ed25519_verify(
                test_case.msg,
                &test_case.sig,
                &test_case.public_key,
                &mut sha_ctx,
            );
            assert_eq!(
                result.is_ok(),
                test_case.expected_ok,
                "Wycheproof TC ID {}: {:?}, msg: {:?}, sig: {:?}, pk: {:?}",
                test_case.tc_id,
                test_case.comment,
                test_case.msg,
                test_case.sig,
                test_case.public_key
            );
        }
    }

    // CCTV test vectors
    // (Test vectors are taken from fd_ed25519_bindings/vendor/ballet/ed25519/test_ed25519_cctv.c)
    #[derive(Debug)]
    struct CctvEd25519VerifyTest {
        tc_id: u32,
        comment: &'static str,
        msg: &'static [u8],
        public_key: [u8; FD_ED25519_PUBLIC_KEY_LEN],
        sig: [u8; FD_ED25519_SIGNATURE_LEN],
        expected_ok: bool,
    }

    const CCTV_TEST_VECTORS: &[CctvEd25519VerifyTest] = &[
        CctvEd25519VerifyTest {
            tc_id: 0,
            comment: "ed25519vectors 3",
            msg: b"ed25519vectors 3",
            sig: hex!("00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"),
            public_key: hex!("0000000000000000000000000000000000000000000000000000000000000000"),
            expected_ok: false,
        },
        CctvEd25519VerifyTest {
            tc_id: 7,
            comment: "ed25519vectors",
            msg: b"ed25519vectors",
            sig: hex!("36684ea91032ba5b1dbab2d02f4debc74c3327f2b3802e2e4d371aa42b12b56bBBFD00BD9C259D8D222D15E67A3D8228585050DBB9B9585BE20D8FADC721DA03"),
            public_key: hex!("10eb7c3acfb2bed3e0d6ab89bf5a3d6afddd1176ce4812e38d9fd485058fdb1f"),
            expected_ok: true,
        },
        // ... More test cases from test_ed25519_cctv.c ...
        CctvEd25519VerifyTest { // Small order pubkey
            tc_id: 82, // Example from small order point tests in C (using one of them as pubkey)
            comment: "Small order public key 0100...00",
            msg: b"some message",
            // Signature (R,S) - R is part of the signature, S is computed. Small order check is on public key.
            // For a small order public key, any signature should be rejected. Let's use a valid-looking one.
            sig: hex!("00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001"), // Bogus S
            public_key: hex!("0100000000000000000000000000000000000000000000000000000000000000"),
            expected_ok: false,
        },
        CctvEd25519VerifyTest {
            tc_id: 50, // Example of malleable signature from C tests, S + L
            comment: "ed25519vectors 5 - malleable S+L",
            msg: b"ed25519vectors 5",
            // Original S: 08f32d206a7c0b7efa9a59e66546e8f1f599ef843fb502c9cc3c4ae8b7c11e05
            // L:          1000000000000000000000000000000014def9dea2f79cd65812631a5cf5d3ed
            // S+L:        18f32d206a7c0b7efa9a59e66546e8f109f30c64e8a2a6716e4ffdd90a6719f2
            sig: hex!("b62cf890de42c413b11b1411c9f01f1c4d77aa87ef182258d1251f69af2a350618f32d206a7c0b7efa9a59e66546e8f109f30c64e8a2a6716e4ffdd90a6719f2"),
            public_key: hex!("10eb7c3acfb2bed3e0d6ab89bf5a3d6afddd1176ce4812e38d9fd485058fdb1f"),
            expected_ok: false, // Malleable signatures should be rejected
        },
    ];

    #[test]
    fn test_ed25519_verify_cctv() {
        for test_case in CCTV_TEST_VECTORS {
            let mut sha_ctx = new_sha_context();
            let result = fd_ed25519_verify(
                test_case.msg,
                &test_case.sig,
                &test_case.public_key,
                &mut sha_ctx,
            );
            assert_eq!(
                result.is_ok(),
                test_case.expected_ok,
                "CCTV TC ID {}: {:?}, msg: {:?}, sig: {:?}, pk: {:?}",
                test_case.tc_id,
                test_case.comment,
                test_case.msg,
                test_case.sig,
                test_case.public_key
            );
            if !test_case.expected_ok {
                // Check specific error codes if desired, C returns ERR_SIG for most of these
                assert!(
                    result == Err(FD_ED25519_ERR_SIG) || result == Err(FD_ED25519_ERR_PUBKEY),
                    "Expected error for TC {}",
                    test_case.tc_id
                );
            }
        }
    }

    #[test]
    fn test_ed25519_point_validate_tests() {
        let zero_point = hex!("0100000000000000000000000000000000000000000000000000000000000000"); // Identity element
        assert!(fd_ed25519_point_validate(&zero_point));

        let valid_point_1 =
            hex!("26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc05"); // Small order point, but valid encoding
        assert!(
            fd_ed25519_point_validate(&valid_point_1),
            "Small order point (valid encoding) should pass validate"
        );

        let valid_point_2 =
            hex!("c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac03fa"); // Small order point, valid encoding
        assert!(
            fd_ed25519_point_validate(&valid_point_2),
            "Small order point (valid encoding) should pass validate"
        );

        // Negative tests (invalid points from C test)
        let invalid_point_1 =
            hex!("0200000000000000000000000000000000000000000000000000000000000000"); // y >= p
        assert!(
            !fd_ed25519_point_validate(&invalid_point_1),
            "Point with y >= p should be invalid"
        );

        let invalid_point_2 =
            hex!("b898e00f6f6df758b3f9a05cbf73b15fd392a008a9a417d471c178c1b28c7447"); // Not on curve
        assert!(
            !fd_ed25519_point_validate(&invalid_point_2),
            "Point not on curve should be invalid"
        );

        // Test points from test_affine_is_small_order that are small order but should pass point_validate
        // (as point_validate doesn't itself check for small order, only encoding and curve equation)
        let small_order_valid_encoding_1 =
            hex!("0100000000000000000000000000000000000000000000000000000000000000");
        assert!(
            fd_ed25519_point_validate(&small_order_valid_encoding_1),
            "Small order point with valid encoding (not identity) should pass validate"
        );

        let small_order_valid_encoding_2 =
            hex!("ecffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7f"); // -1 (mod p)
        assert!(
            fd_ed25519_point_validate(&small_order_valid_encoding_2),
            "Small order point (-1 mod p) with valid encoding should pass validate"
        );
    }

    #[test]
    fn test_batch_verify_cctv() {
        let cctv_valid_idx = CCTV_TEST_VECTORS
            .iter()
            .position(|tc| tc.expected_ok)
            .unwrap();
        let cctv_invalid_idx = CCTV_TEST_VECTORS
            .iter()
            .position(|tc| !tc.expected_ok)
            .unwrap();

        let valid_tc = &CCTV_TEST_VECTORS[cctv_valid_idx];
        let invalid_tc = &CCTV_TEST_VECTORS[cctv_invalid_idx];

        let mut items: Vec<Ed25519BatchVerificationItem> = Vec::new();

        // Batch of 2: 1 valid, 1 invalid (invalid pubkey or sig)
        let mut sha_context1 = new_sha_context();
        let mut sha_context2 = new_sha_context();

        items.push(Ed25519BatchVerificationItem {
            signature: &valid_tc.sig,
            public_key: &valid_tc.public_key,
            sha_context: &mut sha_context1,
        });
        items.push(Ed25519BatchVerificationItem {
            // This one uses an invalid signature/pubkey from CCTV
            signature: &invalid_tc.sig,
            public_key: &invalid_tc.public_key,
            sha_context: &mut sha_context2,
        });

        // The C test_cctv_batch uses the same message for all batch items.
        // We need a common message. Let's pick the message from the valid_tc.
        let common_msg = valid_tc.msg;

        let result = fd_ed25519_verify_batch_single_msg(common_msg, &mut items);
        assert_ne!(
            result,
            Ok(()),
            "Batch verification with one invalid item should fail. TC IDs: {}, {}",
            valid_tc.tc_id,
            invalid_tc.tc_id
        );

        // Batch of 2 valid signatures
        items.clear();
        let mut sha_context1 = new_sha_context();
        let mut sha_context2 = new_sha_context();

        items.push(Ed25519BatchVerificationItem {
            signature: &valid_tc.sig,
            public_key: &valid_tc.public_key,
            sha_context: &mut sha_context1,
        });
        items.push(Ed25519BatchVerificationItem {
            // Use another valid one. If not enough, reuse.
            signature: &valid_tc.sig, // Re-use for simplicity, or find another valid one
            public_key: &valid_tc.public_key,
            sha_context: &mut sha_context2,
        });
        let result_all_valid = fd_ed25519_verify_batch_single_msg(common_msg, &mut items);
        assert_eq!(
            result_all_valid,
            Ok(()),
            "Batch verification with all valid items should succeed. TC ID: {}",
            valid_tc.tc_id
        );

        // Test edge case: Batch size 1 (valid)
        items.truncate(1);
        let result_batch_1 = fd_ed25519_verify_batch_single_msg(common_msg, &mut items);
        assert_eq!(
            result_batch_1,
            Ok(()),
            "Batch verification with 1 valid item should succeed. TC ID: {}",
            valid_tc.tc_id
        );

        // Test edge case: Batch size 1 (invalid)
        items.clear();
        let mut sha_context1 = new_sha_context();
        items.push(Ed25519BatchVerificationItem {
            signature: &invalid_tc.sig,
            public_key: &invalid_tc.public_key,
            sha_context: &mut sha_context1,
        });
        // Using invalid_tc.msg here, as the signature was generated for it.
        let result_batch_1_invalid = fd_ed25519_verify_batch_single_msg(invalid_tc.msg, &mut items);
        assert_ne!(
            result_batch_1_invalid,
            Ok(()),
            "Batch verification with 1 invalid item should fail. TC ID: {}",
            invalid_tc.tc_id
        );
    }

    #[test]
    fn test_strerror_unknown_code() {
        // Use a code not defined in the FD_ED25519_ERR_* list
        let unknown_error_code = -100;
        // The C function returns "unknown" for codes it doesn't recognize.
        assert_eq!(fd_ed25519_strerror(unknown_error_code), "unknown");
    }
}
